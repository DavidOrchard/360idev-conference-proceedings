
//   ****************************************************************************
//  ******************************************************************************
// ********************************************************************************
// **** ===========================================================================
// ****  Name     : CommonTransform.cpp
// ****  Part of  : Transform
// ****  Created  : 09/12/2004 by Emanuele Cipolloni
// ****  Description:
// ****     The main class implementation for the application Transform.
// ****
// ****
// ****     Initial content was generated by eyeGT Creator.
// ****
// ****  Version  : 1.1
// ****  Copyright: (C) Copyright 2001-2004 by Barefoot Software Inc.
// **** ===========================================================================
// ********************************************************************************
//  ******************************************************************************
//   ****************************************************************************

// INCLUDE FILES
#include "CommonTransform.h"

#if defined(UNDER_WIN32)
#include "stdafx.h"
#endif

#if defined(UNDER_SYMBIAN)
#include <libc/stdio.h>
#include <libc/stdlib.h>
#include <libc/sys/stat.h>

#include <e32math.h>

#include <e32std.h>

#include <fbs.h>

#include <eikenv.h>
#include <eikappui.h>
#include <eikapp.h>

#include <f32file.h>

#include <bautils.h>

#include <plpvariant.h>

#include <coemain.h>
#include <coeaui.h>
#endif

#include <math.h>

#include <string.h>


//eyeGT Main Includes
#include "eyeGT.h"
#include "eyeGTSym.h"
#include "eyeGTTypes.h"

#if defined(__ARM__)
#include "SocketsEngine.h"
#include "Sockets.pan"
#endif

#if defined(__WINS__)
#include "HTTPInterface.h"
#endif

//Jpeg decompressor Interface
#include "JPEG_dec.h"

//Utilities
#include "eyeGT_Utilities.h"

//Change the shape every nth frames (when in auto mode)
#define CHANGE_COUNT   300

#if defined(UNDER_CE_SE)
#define BOTTOM_BORDER 40
#else
#define BOTTOM_BORDER 20
#endif


// ================= MEMBER FUNCTIONS =======================

// Constructor
CCommonTransform::CCommonTransform(char* ApplicationPath, int ScreenDepth, bool ScreenInverted, int ScreenWidth, int ScreenHeight)
	{
	//Joystick is at rest at the beginning
	jdir = jIdle;
	
	Accel 		= 0;
	AccelTime 	= 0;

	BlinkCount 	= 0;
	FaderCount 	= 0;

	FaderMaxIdx     = 0;
	FaderOn			= false;
	FadingIn		= true;
	FadeAllowAction = false;
	FaderInited		= false;

	MessageIdx = 0;


	BottomFading		= false;
	BottomFadingIn		= false;
	BottomFadingLevel	= 0;

	MessageCounter		= 0;

	FadeBannerAllowed	= false;

	//Copy the application path
	AppPath = (char*) malloc(strlen(ApplicationPath) + 1);
	memset(AppPath, 0, strlen(ApplicationPath) + 1);
	strcpy(AppPath, ApplicationPath);
		
	DoBanner = false;

	ClientWidth = ScreenWidth;
	ClientHeight = ScreenHeight;

	Bottombar_Hide_Pos = ClientHeight + 20;
	Bottombar_Norm_Pos = ClientHeight - 20;


	//Allocate and initialize the Canvas
	eyeGTCanvas = egtCreateCanvas();
	
	#if defined(UNDER_PSP)
	egtSetCanvasProperties(eyeGTCanvas, 512, ClientHeight, ScreenDepth, ScreenInverted);
	#else
	egtSetCanvasProperties(eyeGTCanvas, ClientWidth, ClientHeight, ScreenDepth, ScreenInverted);
	#endif 

	egtSetRGBFieldLayout(eyeGTCanvas, rgb565);

	egtSetBackgroundColor(eyeGTCanvas, 128, 128, 255);

	if (ScreenDepth < 24)
	{
		egtSetBitmapDither(eyeGTCanvas, DITHER_OFF);
		egtSetSolidColorDither(eyeGTCanvas, DITHER_OFF);
	}
	
	egtSetUpdateRate(eyeGTCanvas, 30);

	//Zero all the objects handler
	ArialBoldFont		= 0;

	
	#if defined(DEVICE_HAS_TOUCHSCREEN)
	CMToolbarShape		= 0;
	tbButtons			= 0;
	tbfocusButtons		= 0;
	pointerisdown		= false;

	tbHidden			= true;
	tbCanBeHidden		= false;
	tbMoving			= false;
	tbRaising			= true;
	tbyPos				= Bottombar_Hide_Pos;
	#endif


	// open file, leave if error
	sprintf(TempBuffer, "%s%s%s", AppPath, stViewerAssets, "ArialBlack.fnt");
	int CMFontLen = efReadParticleFile(&ArialBoldFont, TempBuffer);

	//load the Arial Bold font
	if (CMFontLen > 0)
	{
		egtLoadFont(eyeGTCanvas, pidARIALBOLDFONT, ArialBoldFont, CMFontLen, false);
	}


	#if defined(DEVICE_HAS_TOUCHSCREEN)
	sprintf(TempBuffer, "%s%s", AppPath, "/TransformToolbar.mhp");
	int CMToolbarLen = efReadParticleFile(&CMToolbarShape, TempBuffer);
		
	if (CMToolbarLen > 0)
	{
		egtLoadMultiShape(eyeGTCanvas, pidCMTBEXITSHAPE, 4, CMToolbarShape, CMToolbarLen, false);
	}
	#endif



	//Display the first banner
	SetupBottomBanner(mlNormal);

	//Start the fader
	FaderOn = false;
	FadeBannerAllowed = true;

		
	//Raise the toolbar
	#if defined(DEVICE_HAS_TOUCHSCREEN)
	tbMoving = true;
	#endif

	Jpeg_Decompressor = (TJPEG_Decompressor*) new TJPEG_Decompressor;

	//The shape we load
	TwirlShape = 0;
	WalkingLady = 0;

	//These keep tracks of the button instanced ID 
	//Note: to be precise we place containers with buttons on them,
	//      so these are the instances of the containers.
	PointA = 0;
	PointB = 0;
	PointC = 0;

	//This keep track of the triangle instance
	tri1 = 0;
	base = 0;
	type = 0;
	shape = 0;

	//this will true when we are dragging a button
	dragging = false;

	//This is true when we are doing automatic animation
	#if defined(UNDER_PSP)
	Auto = true;
	#else
	Auto = false;
	#endif

	//These are the deltas used by the animation
	dx1 = 6.0;
	dy1 = 5.0;
	dx2 = 8.0;
	dy2 = -4.0;
	dx3 = -4.0;
	dy3 = 2.0;

	//The type of shape we are currently displaying
	ShapeType = -1;

	//The change counter
	ChangeCnt = 0;
		
	//Load all the resources needed by the demo
	LoadResources();

	//Create the buttons and place then on the screen
	CreateButtons();

	//Create the triangle and place it on the screen
	CreateTriangle();

	//Create the wallpaper
	//CreateWallpaper();

	//Trigger the first transformation
	ChangeShape();

	Transform();

	}


// Destructor
CCommonTransform::~CCommonTransform()
    {

	DeleteBottomBanner();

	egtDestroyCanvas(eyeGTCanvas);

	delete Jpeg_Decompressor;
		
	if (AppPath) free(AppPath);

	if (ArialBoldFont) free(ArialBoldFont);

	#if defined(DEVICE_HAS_TOUCHSCREEN)
	if (CMToolbarShape) free(CMToolbarShape);
	#endif

	#if defined(UNDER_SYMBIAN)
	CloseSTDLIB();
	#endif

    }

void CCommonTransform::HandleJoystickButton()
	{
	}

void CCommonTransform::ZoomIn( void )
	{
	}

void CCommonTransform::ZoomOut( void )
	{
	}

void CCommonTransform::DoPeriodTask()
	{
	HandleJoystick();

	if (Auto)
	{
		ChangeCnt++;

		if (ChangeCnt == CHANGE_COUNT)
		{
			ChangeCnt = 0;
			ChangeShape();
		}

		SFLOAT x1, y1, x2, y2, x3, y3;

		//We first retrieve the position of the buttons
		egtGetInstanceTranslation(eyeGTCanvas, PointA, &x1, &y1);
		egtGetInstanceTranslation(eyeGTCanvas, PointB, &x2, &y2);
		egtGetInstanceTranslation(eyeGTCanvas, PointC, &x3, &y3);


		//We update the positions
		if ((x1 < 10) || (x1 > ClientWidth -  10)) {dx1 = -dx1; }
		if ((y1 <  10) || (y1 > ClientHeight - BOTTOM_BORDER)) {dy1 = -dy1; }
		
		if ((x2 < 10) || (x2 > ClientWidth - 10)) {dx2 = -dx2; }
		if ((y2 <  10) || (y2 > ClientHeight - BOTTOM_BORDER)) {dy2 = -dy2; }

		if ((x3 < 10) || (x3 > ClientWidth - 10)) {dx3 = -dx3;  }
		if ((y3 <  10) || (y3 > ClientHeight - BOTTOM_BORDER)) {dy3 = -dy3; }

		x1 += dx1;
		y1 += dy1;
		x2 += dx2;
		y2 += dy2;
		x3 += dx3;
		y3 += dy3;

		egtTranslateInstance(eyeGTCanvas, PointA, dx1, dy1, true);
		egtTranslateInstance(eyeGTCanvas, PointB, dx2, dy2, true);
		egtTranslateInstance(eyeGTCanvas, PointC, dx3, dy3, true);

		Transform();
	}


	egtProcessDisplayList(eyeGTCanvas, true);

	egtDrawAllLayers(eyeGTCanvas);
}

void CCommonTransform::SetBottomBanner(int MessageIdx)
	{
		egtSetEditFieldText(eyeGTCanvas, "/BOTTOMFIELD", (char*)MessageGroup[MessageIdx], false);
		egtSetEditFieldText(eyeGTCanvas, "/BOTTOMFIELDSHADOW", (char*)MessageGroup[MessageIdx], false);
	}

void CCommonTransform::FadeBottomBanner()
	{
		if (BottomFading)
		{
			int FadeLevel;

			if (BottomFadingIn)
			{
				BottomFadingLevel++;

				FadeLevel = BottomFadingLevel * 50;

				if (BottomFadingLevel >= 5)
				{
					FadeLevel = 256;
					BottomFading = false;
				}
			}
			else
			{
				BottomFadingLevel--;

				FadeLevel = BottomFadingLevel * 50;

				if (BottomFadingLevel <= 0)
				{
					FadeLevel = 0;
					BottomFading = false;
				}
			}

			egtAlphaInstance(eyeGTCanvas, "/BOTTOMFIELD",		FadeLevel);
			egtAlphaInstance(eyeGTCanvas, "/BOTTOMFIELDSHADOW", FadeLevel);

			egtAlphaInstance(eyeGTCanvas, "/BANNERSHAPE",		FadeLevel);
			egtAlphaInstance(eyeGTCanvas, "/BANNERSHAPESHADOW", FadeLevel);
		
		}
	}


void CCommonTransform::InitializeFader(int StepSize, bool FadeIn, bool AllowAction)
	{
		FaderOn = false;
		FaderMaxIdx = 0;
		CurrFaderIdx = 0;
		FadingIn = FadeIn;
		FadeStepNum = 0;
		FadeStepSize = StepSize;
		FadeAllowAction = AllowAction;
		FaderInited = true;
	}

void CCommonTransform::AddFaderItem(char* ItemName)
	{
		//Make sure we are in the limits
		if (CurrFaderIdx >= FADER_MAX_ITEMS_NUM) return;

		FaderMaxIdx++;

		memcpy(FaderList[CurrFaderIdx], ItemName, strlen(ItemName));

		FaderList[CurrFaderIdx][strlen(ItemName)] = '\0';

		if (FadingIn)
			egtAlphaInstance(eyeGTCanvas, ItemName, 1);
		
		CurrFaderIdx++;
	}

void CCommonTransform::ClearFaderItem(char* ItemName)
	{
		//Make sure we are in the limits
		
		for (int j = 0; j < FADER_MAX_ITEMS_NUM; j++)
		{
			if (strcmp(FaderList[j], ItemName) == 0)
			{
				//Just clear it
				memset(FaderList[j], 0, FADER_MAX_ITEM_LEN);
			 	
			 	return;
			}
		}
	}

void CCommonTransform::FadeStep()
	{
		FaderInited = false;
		
		if (FadingIn)
		{
			for (int i = 0; i < FaderMaxIdx; i++)
			{
				egtAlphaInstance(eyeGTCanvas, FaderList[i], FadeStepNum * FadeStepSize);
			}
		}
		else
		{
			for (int i = 0; i < FaderMaxIdx; i++)
			{
				egtAlphaInstance(eyeGTCanvas, FaderList[i], 256 - FadeStepNum * FadeStepSize);
			}
		}

		FadeStepNum++;

		//Check if fading is finished
		if (FadingIn)
		{
			if ((FadeStepNum * FadeStepSize) >= 256) 
			{
				FaderOn = false;
				
				//Make sure everything is opaque
				for (int i = 0; i < FaderMaxIdx; i++)
				{
					egtAlphaInstance(eyeGTCanvas, FaderList[i], 256);
				}
			}
		}
		else
		{
			if ((256-(FadeStepNum * FadeStepSize)) <= 0) 
			{
				FaderOn = false;
				
				//Make sure everything is transparent
				for (int i = 0; i < FaderMaxIdx; i++)
				{
					egtAlphaInstance(eyeGTCanvas, FaderList[i], 0);
				}
			}
		}
	}

void CCommonTransform::DeviceKeyboard(TPhoneKeys PhoneKey)
	{
		switch (PhoneKey) {
			case pk0 : 
				{
					egtSetKeyDown(eyeGTCanvas, '0', 0);
				} break;

			case pk1 : 
				{
					egtSetKeyDown(eyeGTCanvas, '1', 0);
				} break;

			case pk2 : 
				{
					egtSetKeyDown(eyeGTCanvas, '2', 0);
				} break;

			case pk3 : 
				{
					egtSetKeyDown(eyeGTCanvas, '3', 0);
				} break;

			case pk4 : 
				{
					egtSetKeyDown(eyeGTCanvas, '4', 0);
				} break;

			case pk5 : 
				{
					egtSetKeyDown(eyeGTCanvas, '5', 0);
				} break;

			case pk6 : 
				{
					egtSetKeyDown(eyeGTCanvas, '6', 0);
				} break;

			case pk7 : 
				{
					egtSetKeyDown(eyeGTCanvas, '7', 0);
				} break;

			case pk8 : 
				{
					egtSetKeyDown(eyeGTCanvas, '8', 0);
				} break;

			case pk9 : 
				{
					egtSetKeyDown(eyeGTCanvas, '9', 0);
				} break;
		}

}

void CCommonTransform::LeftMenuButton()
	{
	}

bool CCommonTransform::RightMenuButton()
	{
		bool res = true;
		return res;

	}

void CCommonTransform::DeleteButton(int Degree)
	{
	}

#if defined(DEVICE_HAS_TOUCHSCREEN)
BOOL SameObj(char* First, char* Second)
{
	return ((First) && (Second) && (strcmp(First, Second) == 0));
}

bool CCommonTransform::PointerDown(int x, int y)
	{
		char* ButtonSelected = 0;
		char* ParentParticle = 0;

		//Check if any button of the interface has been pressed
		//Since touch screen works differently from mouse based
		//devices we can't use the egtGetSelectedButton method
		//as that would require two selections of the button
		//to select it
		
		//Do not allow for any action to happen within fades
		if (FaderOn) return false;

		egtGetInstanceHit(eyeGTCanvas, x, y, &ButtonSelected);

		//Lets check first if any button in the toolbar has been pressed
		if (SameObj(ButtonSelected, "/BTNEXIT"))
		{
			return true;
		}
		else
		if (SameObj(ButtonSelected, "/BTNCHANGE"))
		{
			ChangeShape();

			//just in case we are in auto mode
			ChangeCnt = 0;
		}
		else
		if (SameObj(ButtonSelected, "/BTNAUTO"))
		{
			//Display the first banner
			SetupBottomBanner(mlAuto);

			Auto = true;
		}
		else
		if (SameObj(ButtonSelected, "/BTNSTOP"))
		{
			//Display the first banner
			SetupBottomBanner(mlNormal);

			Auto = false;
		}
		else
		{
			//Are we dragging the picture container
			egtGetInstanceParent(eyeGTCanvas, ButtonSelected, &ParentParticle);

			if (SameObj(ParentParticle, PointA) ||
				SameObj(ParentParticle, PointB) ||
				SameObj(ParentParticle, PointC) )
			{
				pointerisdown = true;		
				egtMouseDown(eyeGTCanvas, x, y);

				dragging = true;
				
				TsRECT rct;
				rct.xmin = 10;
				rct.ymin = 10;
				rct.xmax = ClientWidth - 10;
				rct.ymax = ClientHeight - BOTTOM_BORDER;

				TsPOINT Coords;

				Coords.x = x;
				Coords.y = y;

				egtStartDragContainer(eyeGTCanvas, ParentParticle, &rct, Coords, true);
			}
		}

		return false;
	}

void CCommonTransform::PointerUp(int x, int y)
	{
		if (pointerisdown) 
		{
			pointerisdown = false;
			egtMouseUp(eyeGTCanvas, x, y);
			jdir = jIdle;

			//If we were dragging a button, simply release it
			if (dragging) 
			{
				dragging = false;
				egtEndDragContainer(eyeGTCanvas);
			}
		}
	}

void CCommonTransform::PointerMove(int x, int y)
	{
		if (pointerisdown)
		{
			egtMouseMove(eyeGTCanvas, x, y, pointerisdown);

			if (dragging) Transform();
		}
	}
#endif

void CCommonTransform::HandleJoystick()
{
	if (jdir != jIdle)
	{
		SFLOAT AccelX = 0.0, AccelY = 0.0;

		if (Accel < 8) 
		{ 
			AccelTime++; 

			if (AccelTime > 2)
			{
				Accel++;
				AccelTime = 0;
			}
		}
		
		if (jdir & jDown)	AccelY = -Accel;
		if (jdir & jUp)		AccelY = Accel;
		if (jdir & jRight)	AccelX = -Accel;
		if (jdir & jLeft)	AccelX = Accel;
	
		//TODO : Insert your instruction here
	
	}	
	else
	{
		Accel = 1;
		AccelTime = 0;
	}


}

void CCommonTransform::JoystickButton()
	{
	}


void CCommonTransform::CreateBottomBanner()
	{	

		//Make the shaded bottom banner
		egtCreateShape(eyeGTCanvas, pidBOTTOMBANNER, NULL);
		
		egtCreateGradientFillStyle(eyeGTCanvas, LINEAR_GRADIENT_FILL);
		egtAddGradientFillColorSlot(eyeGTCanvas, 1,   0, CMGradStartColorR, CMGradStartColorG, CMGradStartColorB, 255);
		egtAddGradientFillColorSlot(eyeGTCanvas, 1, 255, CMGradEndColorR,	CMGradEndColorG,   CMGradEndColorB, 255);


		egtBeginMapFill(eyeGTCanvas, 1, -90, FILL_RIGHT, FALSE);
		egtRoundRectangle(eyeGTCanvas, 0, 0, ClientWidth, 15, 8, 8, 0);
		egtEndMapFill(eyeGTCanvas, FILL_RIGHT);

		egtUpdateShapeBounds(eyeGTCanvas, pidBOTTOMBANNER);

		egtPlaceParticleInstance(eyeGTCanvas, pidBOTTOMBANNER, 50001, "BOTTOMBANNER", 0, ClientHeight - 15, NULL, NULL); 
	
		TsFloatRECT rct;

		//Create and place the bottom edit field
		rct.xmin = 0;
		rct.ymin = 0;
		rct.xmax = ClientWidth;
		rct.ymax = 15.0;
	
		egtCreateEditField(eyeGTCanvas, pidBOTTOMFIELD, pidARIALBOLDFONT, 12, rct, NULL, false); 
		egtSetEditFieldOptions(eyeGTCanvas, 0);
		egtSetEditFieldFontColor(eyeGTCanvas, CMBannerForeColorR, CMBannerForeColorG, CMBannerForeColorB, 255);
		egtSetEditFieldTextAlignment(eyeGTCanvas, stextAlignCenter);

		egtCreateEditField(eyeGTCanvas, pidBOTTOMFIELDSHADOW, pidARIALBOLDFONT, 12, rct, NULL, false); 
		egtSetEditFieldOptions(eyeGTCanvas, 0);
		egtSetEditFieldFontColor(eyeGTCanvas, CMBannerShadColorR, CMBannerShadColorG, CMBannerShadColorB, 255);
		egtSetEditFieldTextAlignment(eyeGTCanvas, stextAlignCenter);

		egtPlaceParticleInstance(eyeGTCanvas, pidBOTTOMFIELD,			50021, "BOTTOMFIELD",		  0, ClientHeight - 15 - 3, NULL, NULL);
		egtPlaceParticleInstance(eyeGTCanvas, pidBOTTOMFIELDSHADOW,		50020, "BOTTOMFIELDSHADOW",   1, ClientHeight - 15 - 3, NULL, NULL);
	
		AddFaderItem("/BOTTOMBANNER");
		AddFaderItem("/BOTTOMFIELD");
		AddFaderItem("/BOTTOMFIELDSHADOW");

		DoBanner = true;

	}

void CCommonTransform::DeleteBottomBanner()
	{	
		DoBanner = false;

		egtRemoveInstance(eyeGTCanvas, "/BOTTOMBANNER");
		egtRemoveInstance(eyeGTCanvas, "/BOTTOMFIELD");
		egtRemoveInstance(eyeGTCanvas, "/BOTTOMFIELDSHADOW");
		egtRemoveInstance(eyeGTCanvas, "/BANNERSHAPE");
		egtRemoveInstance(eyeGTCanvas, "/BANNERSHAPESHADOW");


		egtReleaseParticle(eyeGTCanvas, pidBOTTOMBANNER);
		egtReleaseParticle(eyeGTCanvas, pidBOTTOMFIELD); 
		egtReleaseParticle(eyeGTCanvas, pidBOTTOMFIELDSHADOW); 
	}

#if defined(DEVICE_HAS_TOUCHSCREEN)
void CCommonTransform::CreateBottomBar()
	{	

		//Create the container for the bottom bar
		egtCreateContainer(eyeGTCanvas, pidBOTTOMBARCONTAINER);

		//Make the shaded bottom banner
		egtCreateShape(eyeGTCanvas, pidBOTTOMBAR, NULL);
		
		egtCreateGradientFillStyle(eyeGTCanvas, LINEAR_GRADIENT_FILL);
		egtAddGradientFillColorSlot(eyeGTCanvas, 1,   0, CMGradStartColorR, CMGradStartColorG, CMGradStartColorB, 255);
		egtAddGradientFillColorSlot(eyeGTCanvas, 1, 255, CMGradEndColorR,	CMGradEndColorG,   CMGradEndColorB, 255);

		egtBeginMapFill(eyeGTCanvas, 1, -90, FILL_RIGHT, FALSE);
		#if defined(UNDER_CE_SE)
		egtRoundRectangle(eyeGTCanvas, 0, 0, ClientWidth, 40, 8, 8, 0);
		#else
		egtRoundRectangle(eyeGTCanvas, 0, 0, ClientWidth, 20, 8, 8, 0);
		#endif
		egtEndMapFill(eyeGTCanvas, FILL_RIGHT);


		egtUpdateShapeBounds(eyeGTCanvas, pidBOTTOMBAR);

		//egtContainerPlaceParticle(eyeGTCanvas, pidBOTTOMBARCONTAINER, pidBOTTOMBAR, 1, "BOTTOMBARSHADE", 0, 0); 

		egtPlaceParticleInstance(eyeGTCanvas, pidBOTTOMBARCONTAINER, 50001, "BOTTOMBAR", 0, Bottombar_Norm_Pos, NULL, NULL); 
	
		//Create the button with the shape above
		//egtCreateButton(eyeGTCanvas, pidBOTTOMBARHIDDENBUTTON, false);
		//egtButtonPlaceParticle(eyeGTCanvas, pidBOTTOMBARHIDDENBUTTON, pidBOTTOMBAR, sbtnHitTestState, 1, (char*)"ESCILO", 0, 0);



/*
		egtCreateShape(eyeGTCanvas, 9000, NULL);
		egtArc(eyeGTCanvas, 0, 0, 100, 10, 0, 90, 180, true);

*/
	}

void CCommonTransform::RefreshBottomBar()
	{	

		//Make the shaded bottom banner
		egtSelectShape(eyeGTCanvas, pidBOTTOMBAR);
		egtClearShape(eyeGTCanvas, pidBOTTOMBAR, CLEAR_ALL);
		
		egtCreateGradientFillStyle(eyeGTCanvas, LINEAR_GRADIENT_FILL);
		egtAddGradientFillColorSlot(eyeGTCanvas, 1,   0, CMGradStartColorR, CMGradStartColorG, CMGradStartColorB, 255);
		egtAddGradientFillColorSlot(eyeGTCanvas, 1, 255, CMGradEndColorR,	CMGradEndColorG,   CMGradEndColorB, 255);

		egtBeginMapFill(eyeGTCanvas, 1, -90, FILL_RIGHT, FALSE);
		#if defined(UNDER_CE_SE)
		egtRoundRectangle(eyeGTCanvas, 0, 0, ClientWidth, 40, 8, 8, 0);
		#else
		egtRoundRectangle(eyeGTCanvas, 0, 0, ClientWidth, 20, 8, 8, 0);
		#endif
		egtEndMapFill(eyeGTCanvas, FILL_RIGHT);

		egtUpdateShapeBounds(eyeGTCanvas, pidBOTTOMBAR);

		egtRefreshInstance(eyeGTCanvas, "/BOTTOMBAR");

	}

void CCommonTransform::DeleteBottomBar()
	{	

		egtRemoveInstance(eyeGTCanvas, "/BOTTOMBAR/BTNEXIT");
		egtRemoveInstance(eyeGTCanvas, "/BOTTOMBAR/BTNCHANGE");
		egtRemoveInstance(eyeGTCanvas, "/BOTTOMBAR/BTNAUTO");
		egtRemoveInstance(eyeGTCanvas, "/BOTTOMBAR/BTNSTOP");
		
		egtRemoveInstance(eyeGTCanvas, "/BOTTOMBAR");
		egtRemoveInstance(eyeGTCanvas, "/BOTTOMBARHIDDENBTN");
	
		egtReleaseParticle(eyeGTCanvas, pidBOTTOMBARCONTAINER);
		egtReleaseParticle(eyeGTCanvas, pidBOTTOMBAR);
		egtReleaseParticle(eyeGTCanvas, pidBOTTOMBARHIDDENBUTTON);

	}

void CCommonTransform::SetupBottomBar()
{

	//Remove all the buttons first
	egtRemoveInstance(eyeGTCanvas, "BTNEXIT");
	egtRemoveInstance(eyeGTCanvas, "BTNCHANGE");
	egtRemoveInstance(eyeGTCanvas, "BTNAUTO");
	egtRemoveInstance(eyeGTCanvas, "BTNSTOP");

	//Start with the commands from the right
	SFLOAT startx = ClientWidth - 10;

	#if !defined(UNDER_CE_SE)
	const SFLOAT scaler = 120.0;
	const SFLOAT filler = 2.0;
	const SFLOAT starty = 430;
	#else
	const SFLOAT scaler = 340.0;
	const SFLOAT filler = 4.0;
	const SFLOAT starty = 20;
	#endif


	if (tbButtons & tbExit)
	{
		TsFloatRECT rctBounds;

		egtGetShapeBounds(eyeGTCanvas, pidCMTBEXITSHAPE, &rctBounds);

		SFLOAT btnWidth = (rctBounds.xmax - rctBounds.xmin) * scaler / 100;

		startx -= btnWidth / 2 + filler;

		egtPlaceParticleInstance(eyeGTCanvas, pidCMTBEXITSHAPE, 60000, "BTNEXIT", startx, starty, NULL, NULL);
		egtScaleInstance(eyeGTCanvas, "/BTNEXIT", scaler / 100.0, scaler / 100.0, false);

		startx -= btnWidth / 2 + filler;

	}
	
	if (tbButtons & tbAuto)
	{
		TsFloatRECT rctBounds;

		egtGetShapeBounds(eyeGTCanvas, pidCMTBAUTOSHAPE, &rctBounds);

		SFLOAT btnWidth = (rctBounds.xmax - rctBounds.xmin) * scaler / 100;

		startx -= btnWidth / 2 + filler;

		egtPlaceParticleInstance(eyeGTCanvas, pidCMTBAUTOSHAPE,  60001, "BTNAUTO", startx, starty, NULL, NULL);
		egtScaleInstance(eyeGTCanvas, "/BTNAUTO", scaler / 100.0, scaler / 100.0, false);

		startx -= btnWidth / 2 + filler;

	}

	if (tbButtons & tbStop)
	{
		TsFloatRECT rctBounds;

		egtGetShapeBounds(eyeGTCanvas, pidCMTBSTOPSHAPE, &rctBounds);

		SFLOAT btnWidth = (rctBounds.xmax - rctBounds.xmin) * scaler / 100;

		startx -= btnWidth / 2 + filler;

		egtPlaceParticleInstance(eyeGTCanvas, pidCMTBSTOPSHAPE,  60002, "BTNSTOP", startx, starty, NULL, NULL);
		egtScaleInstance(eyeGTCanvas, "/BTNSTOP", scaler / 100.0, scaler / 100.0, false);

		startx -= btnWidth / 2 + filler;

	}

	if (tbButtons & tbChange)
	{
		TsFloatRECT rctBounds;

		egtGetShapeBounds(eyeGTCanvas, pidCMTBCHANGESHAPE, &rctBounds);

		SFLOAT btnWidth = (rctBounds.xmax - rctBounds.xmin) * scaler / 100;

		startx -= btnWidth / 2 + filler;

		egtPlaceParticleInstance(eyeGTCanvas, pidCMTBCHANGESHAPE,  60003, "BTNCHANGE", startx, starty, NULL, NULL);
		egtScaleInstance(eyeGTCanvas, "/BTNCHANGE", scaler / 100.0, scaler / 100.0, false);

		startx -= btnWidth / 2 + filler;

	}
}
#endif

void CCommonTransform::SetupBottomBanner(TMessagelimites MsgGroup)
{
	//Save the message group
	ActualMsgGroup = MsgGroup;

	DoBanner = false;

	//Remove old shape
	egtRemoveInstance(eyeGTCanvas, "/BANNERSHAPE");
	egtRemoveInstance(eyeGTCanvas, "/BANNERSHAPESHADOW");

	//DoPeriodTask();

	memset(MessageGroup, 0, 6 * 30);

	switch(MsgGroup) {
		case mlNormal :
		{
			for (int i = 0; i < 6; i++)
				strcpy(MessageGroup[i], (char*) NormalMsg[i]);
		} break;

		case mlAuto :
		{
			for (int i = 0; i < 6; i++)
				strcpy(MessageGroup[i], (char*) AutoMsg[i]);
		} break;
	}
	
	MessageLimit = MessagesLimit[MsgGroup];

	MessageIdx = 0;

	DoBanner = true;

	SetBottomBanner(MessageIdx);

	#if defined(DEVICE_HAS_TOUCHSCREEN)
	tbButtons = ToolbarConfig[MsgGroup];

	SetupBottomBar();
	#endif
}

void CCommonTransform::LoadResources()
{
	sprintf(TempBuffer, "%s%s", AppPath, "/TwirlShape.shp");
	int TwirlShapeLen = efReadParticleFile(&TwirlShape, TempBuffer);
		
	if (TwirlShapeLen > 0)
	{
		egtLoadShape(eyeGTCanvas, pidTWIRLSHAPE, TwirlShape, TwirlShapeLen, true);

		free(TwirlShape);

		TwirlShape = NULL;
	}


	//sprintf(TempBuffer, "%s%s", AppPath, "WalkingLady.mhp");
	sprintf(TempBuffer, "%s%s%s", AppPath, stViewerAssets, "WalkingLady.mhp");
	int WalkingLadyLen = efReadParticleFile(&WalkingLady, TempBuffer);
		
	if (WalkingLadyLen > 0)
	{
		egtLoadMultiShape(eyeGTCanvas, pidWALKINGLADY, 29, WalkingLady, WalkingLadyLen, true);

		free(WalkingLady);

		WalkingLady = NULL;
	}


	//Load the bitmap
  	U8* Bits = 0;
    FILE* src_file;

	//sprintf(TempBuffer, "%s%s", AppPath, "Clown.jpg");
	sprintf(TempBuffer, "%s%s%s", AppPath, stViewerAssets, "Clown.jpg");
	//sprintf(TempBuffer, "%s%s", AppPath, "Dynacomware.jpg");
 
    //Open The file
    src_file = fopen(TempBuffer, "rb");

	if (!src_file) return;
	
	egtCreateShape(eyeGTCanvas, pidCLOWNSHAPE, NULL);

	Jpeg_Decompressor->Initialize(eyeGTCanvas, pidCLOWNBITMAP, src_file, true);
	Jpeg_Decompressor->SetShapeInstance("/CLOWN");

	Jpeg_Decompressor->ReadJPEGHeader();

	U16 BmpWidth	= Jpeg_Decompressor->ImageWidth;
	U16 BmpHeight	= Jpeg_Decompressor->ImageHeight;

	if (Jpeg_Decompressor->ReadJPEGImage())
	{
		Jpeg_Decompressor->Finalize();
	}

	fclose(src_file);

	egtSetBitmapSmooth(eyeGTCanvas, pidCLOWNBITMAP, false);

	egtClearShape(eyeGTCanvas, pidCLOWNSHAPE, CLEAR_ALL);
	egtSelectShape(eyeGTCanvas, pidCLOWNSHAPE);

	egtCreateBitmapFillStyle(eyeGTCanvas, pidCLOWNBITMAP, CLIPPED_BITMAP_FILL);

	//Now modify the shape to make it a triangle
	//Scale the fill to fit the image
	egtScaleFill(eyeGTCanvas, 1, 0.28, 0.28, false);

	//Move the fill up and right
	//egtTranslateFill(eyeGTCanvas, 1, -38, -60, false);
	//Move the fill up and right
	egtTranslateFill(eyeGTCanvas, 1, -44, -51, false);

	//A black pen
	//egtCreatePenStyle(eyeGTCanvas, 0.1, 0, 0, 0, 255);

	//egtSelectPenStyle(eyeGTCanvas, 1);

	egtSelectFillStyle(eyeGTCanvas, 1, FILL_RIGHT);

	egtMoveTo(eyeGTCanvas, -50, 29);
	egtLineTo(eyeGTCanvas, 0, -57.7);
	egtLineTo(eyeGTCanvas, 50, 29);
	egtLineTo(eyeGTCanvas, -50, 29);

	egtUpdateShapeBounds(eyeGTCanvas, pidCLOWNSHAPE);
}

//Create the buttons and place then on the screen
void CCommonTransform::CreateButtons()
{

	//First create the shape that will make the button
	
	//Create a simple shape containing just a red disk
	egtCreateShape(eyeGTCanvas, pidREDDISKSHAPE, NULL);
	egtCreateColorFillStyle(eyeGTCanvas, 255, 0, 0, 255);
	egtSelectFillStyle(eyeGTCanvas, 1, FILL_RIGHT);
	#if defined(UNDER_CE_SE)
	egtCircle(eyeGTCanvas, 0, 0, 14);
	#else
	egtCircle(eyeGTCanvas, 0, 0, 20);
	#endif
	egtUpdateShapeBounds(eyeGTCanvas, pidREDDISKSHAPE);
	egtChangeCenter(eyeGTCanvas, pidREDDISKSHAPE, cmCustom, 0, 0, false);


	egtCreateShape(eyeGTCanvas, pidREDDISKSHAPE + 1000, NULL);
	egtCreateColorFillStyle(eyeGTCanvas, 255, 0, 0, 255);
	egtSelectFillStyle(eyeGTCanvas, 1, FILL_RIGHT);
	#if defined(UNDER_CE_SE)
	egtCircle(eyeGTCanvas, 0, 0, 14);
	#else
	egtCircle(eyeGTCanvas, 0, 0, 20);
	#endif
	egtUpdateShapeBounds(eyeGTCanvas, pidREDDISKSHAPE + 1000);
	egtChangeCenter(eyeGTCanvas, pidREDDISKSHAPE + 1000, cmCustom, 0, 0, false);


	//Create a button using the shape above for all four states
	//to make it look more interesting we alter the tint of the down state
	egtCreateButton(eyeGTCanvas, pidDRAGBUTTON, false);

	egtButtonPlaceParticle(eyeGTCanvas, pidDRAGBUTTON, pidREDDISKSHAPE, sbtnUpState, 1, "", 0, 0);
	egtButtonPlaceParticle(eyeGTCanvas, pidDRAGBUTTON, pidREDDISKSHAPE, sbtnDownState, 2, "", 0, 0);
	egtButtonTintParticle(eyeGTCanvas, pidDRAGBUTTON, 2, 100, 0, 255, 0);
	egtButtonPlaceParticle(eyeGTCanvas, pidDRAGBUTTON, pidREDDISKSHAPE, sbtnOverState, 3, "", 0, 0);
	egtButtonPlaceParticle(eyeGTCanvas, pidDRAGBUTTON, pidREDDISKSHAPE, sbtnHitTestState, 4, "", 0, 0);
	
	//Since we need to drag the buttons around the screen and button
	//particles are not draggable, we insert the button in a container
	egtCreateContainer( eyeGTCanvas, pidDRAGBUTTONCONTAINER );
	egtContainerPlaceParticle(eyeGTCanvas, pidDRAGBUTTONCONTAINER, pidDRAGBUTTON, 10, NULL, 0, 0);

	x1 = 90;
	y1 = 20;
	x2 = 150;
	y2 = 150;
	x3 = 20;
	y3 = 150;

	egtPlaceParticleInstanceFP(eyeGTCanvas, pidDRAGBUTTONCONTAINER, 11, NULL, 90.0 * 20.0, 20.0 * 20.0, 0, &PointA);
	egtPlaceParticleInstanceFP(eyeGTCanvas, pidDRAGBUTTONCONTAINER, 12, NULL, 200.0 * 20.0, 200.0 * 20.0, 0, &PointB);
	egtPlaceParticleInstanceFP(eyeGTCanvas, pidDRAGBUTTONCONTAINER, 13, NULL, 20.0 * 20.0, 200.0 * 20.0, 0, &PointC);
}

//Create the triangle and place it on the screen
void CCommonTransform::CreateTriangle()
{

	//Create a simple filled traingle shape
	TsFloatRECT rct;
	
	rct.xmin = -50;
	rct.ymin = -57.7;
	rct.xmax = 50;
	rct.ymax = 29;

	egtCreateShape(eyeGTCanvas, pidYELLREDSHAPE, &rct);

	//A nice red-yellow gradient fill
	egtCreateGradientFillStyle(eyeGTCanvas, LINEAR_GRADIENT_FILL);
	egtAddGradientFillColorSlot(eyeGTCanvas, 1, 0, 255, 0, 0, 255);
	egtAddGradientFillColorSlot(eyeGTCanvas, 1, 255, 255, 255, 0, 255);

	//A black pen
	//egtCreatePenStyle(eyeGTCanvas, 0.1, 0, 0, 0, 255);

	//egtSelectPenStyle(eyeGTCanvas, 1);

	egtBeginMapFill(eyeGTCanvas, 1, 90, FILL_RIGHT, false);
	egtMoveTo(eyeGTCanvas, -50, 29);
	egtLineTo(eyeGTCanvas, 0, -57.7);
	egtLineTo(eyeGTCanvas, 50, 29);
	egtLineTo(eyeGTCanvas, -50, 29);
	egtEndMapFill(eyeGTCanvas, FILL_RIGHT);

	//another shaded triangle for the background of the "walking lady" 
	egtCreateShape(eyeGTCanvas, pidWALKLADYSHAPE, &rct);

	//A blue-yellow gradient fill
	egtCreateGradientFillStyle(eyeGTCanvas, LINEAR_GRADIENT_FILL);
	egtAddGradientFillColorSlot(eyeGTCanvas, 1, 0, 0, 0, 255, 255);
	egtAddGradientFillColorSlot(eyeGTCanvas, 1, 255, 255, 255, 0, 255);

	//A black pen
	//egtCreatePenStyle(eyeGTCanvas, 0.1, 0, 0, 0, 255);

	//egtSelectPenStyle(eyeGTCanvas, 1);

	egtBeginMapFill(eyeGTCanvas, 1, 90, FILL_RIGHT, false);
	egtMoveTo(eyeGTCanvas, -50, 29);
	egtLineTo(eyeGTCanvas, 0, -57.7);
	egtLineTo(eyeGTCanvas, 50, 29);
	egtLineTo(eyeGTCanvas, -50, 29);
	egtEndMapFill(eyeGTCanvas, FILL_RIGHT);



	rct.xmin = -79;
	rct.ymin = -78.05;
	rct.xmax =  79;
	rct.ymax =  78.05;

	//a strange shape with alpha fill 
	egtCreateShape(eyeGTCanvas, pidSTRANGESHAPE, &rct);

	//A partially transparent orange fill
	egtCreateColorFillStyle(eyeGTCanvas, 255, 200, 0, 128);

	//A black pen
	//egtCreatePenStyle(eyeGTCanvas, 0.1, 0, 0, 0, 255);

	//egtSelectPenStyle(eyeGTCanvas, 1);

	egtSelectFillStyle(eyeGTCanvas, 1, FILL_RIGHT);

    egtMoveTo(eyeGTCanvas, 53.45, 8.65);
    egtLineTo(eyeGTCanvas, 79.05, -32.35);
    egtLineTo(eyeGTCanvas, 39.25, -48.5);
    egtLineTo(eyeGTCanvas, 3.45, -78.05);
    egtLineTo(eyeGTCanvas, -35.6, -41.95);
    egtLineTo(eyeGTCanvas, -79, -58.4);
    egtLineTo(eyeGTCanvas, -46.55, 8.65);
    egtLineTo(eyeGTCanvas, -31.05, 20.05);
    egtLineTo(eyeGTCanvas, -31.05, 78.1);
    egtLineTo(eyeGTCanvas, 10.9, 22.6);
    egtLineTo(eyeGTCanvas, 62.15, 71.15);
    egtLineTo(eyeGTCanvas, 53.45, 8.65);
	
	egtCreateContainer(eyeGTCanvas, pidMAINCONT);

	//We now place an instance of the triangle
	egtContainerPlaceParticle(eyeGTCanvas, pidMAINCONT, 150, 105, NULL, 0, 0);

	//First level container, this contain the shape to be transformed
	egtCreateContainer(eyeGTCanvas, pidFIRSTCONT);

	//We now place an instance of the triangle
	egtContainerPlaceParticle(eyeGTCanvas, pidFIRSTCONT, pidMAINCONT, 100, NULL, 0, 57.75);

	//Second level container
	egtCreateContainer(eyeGTCanvas, pidSECONDCONT);

	egtContainerPlaceParticle(eyeGTCanvas, pidSECONDCONT, pidFIRSTCONT, 99, NULL, 0, 0);

	//Third level container
	egtCreateContainer(eyeGTCanvas, pidTHIRDCONT);

	egtContainerPlaceParticle(eyeGTCanvas, pidTHIRDCONT, pidSECONDCONT, 98, NULL, 0, 0);

	//Finally place the main container on the canvas
	egtPlaceParticleInstance(eyeGTCanvas, pidTHIRDCONT, 8, NULL, 97, 100, 0, &tri1);

	//Now we can the the instance path to the container
	egtGetInstancePath(eyeGTCanvas, tri1, &base, 0);

	egtGetInstancePath(eyeGTCanvas, base, &type, 0);

	egtGetInstancePath(eyeGTCanvas, type, &shape, 0);
}


//Create the wallpaper
void CCommonTransform::CreateWallpaper()
{

	//Create the logo background
	egtCreateShape(eyeGTCanvas, pidBACKGROUNDSHAPE, NULL);
	//A light blue opaque color fill
	egtCreateColorFillStyle(eyeGTCanvas, 80, 80, 255, 255);

	egtSelectFillStyle(eyeGTCanvas, 1, FILL_RIGHT);

	#if defined(UNDER_PSP)
	egtRoundRectangle(eyeGTCanvas, 10, 10, ClientWidth - 20, ClientHeight - 20, 10, 10, 0);
	#else
	egtRoundRectangle(eyeGTCanvas, 10, 10, ClientWidth - 20, ClientHeight - 20, 10, 10, 0);
	#endif
	
	egtUpdateShapeBounds(eyeGTCanvas, pidBACKGROUNDSHAPE);

	//Place the wall paper in the root Display List
	egtPlaceParticleInstance(eyeGTCanvas, pidBACKGROUNDSHAPE, 1, NULL, 0, 0, 0, NULL);
}

void CCommonTransform::ChangeShape()
{
	ShapeType++;

	if (ShapeType > 4) ShapeType = 0;

	//we first remove the shape in the container
	egtClearContainer(eyeGTCanvas, pidMAINCONT);
	egtRefreshInstance(eyeGTCanvas, shape);

	//Reset all the transformation applied to the containers
	egtRotateInstance(eyeGTCanvas, tri1, 0, false);
	egtScaleInstance(eyeGTCanvas, tri1, 100.0 / 100.0, 100.0 / 100.0, false);
	egtRotateInstance(eyeGTCanvas, base, 0, false);
	egtScaleInstance(eyeGTCanvas, base, 100.0 / 100.0, 100.0 / 100.0, false);
	egtRotateInstance(eyeGTCanvas, type, 0, false);

	switch (ShapeType) {
		case 0:
			{
				//We now place an instance of the original triangle
				egtContainerPlaceParticle(eyeGTCanvas, pidMAINCONT, pidYELLREDSHAPE, 105, NULL, 0, 0);
			}
			break;

		case 1:
			{
				//We now place an instance of the textured (twirl) triangle
				egtContainerPlaceParticle(eyeGTCanvas, pidMAINCONT, pidTWIRLSHAPE, 105, NULL, 0, -15);
			}
			break;

		case 2:
			{
				//We now place an instance of the "strange" shape
				egtContainerPlaceParticle(eyeGTCanvas, pidMAINCONT, pidSTRANGESHAPE, 105, NULL, -4, 20);
			}
			break;

		case 3:
			{
				//We now place an instance of the textured (clown) triangle
				egtContainerPlaceParticle(eyeGTCanvas, pidMAINCONT, pidCLOWNSHAPE, 105, NULL, 0, 0);
			}
			break;

		case 4:
			{
				egtContainerPlaceParticle(eyeGTCanvas, pidMAINCONT, pidWALKLADYSHAPE, 104, NULL, 0, 0);
	
				for (int frm = 0; frm < 29; frm++)
				{
					//We now place an instance of the triangle
					egtContainerPlaceParticle(eyeGTCanvas, pidMAINCONT, pidWALKINGLADY + frm, 105, NULL, -18, -40);
					egtContainerScaleParticle(eyeGTCanvas, pidMAINCONT, 105, 25.0 / 100.0, 25.0 / 100.0, false);
					egtContainerAddFrame(eyeGTCanvas, pidMAINCONT);
					egtContainerRemoveParticle(eyeGTCanvas, pidMAINCONT, 105);
				}
			}
			break;
	}

	Transform();

}

void CCommonTransform::Transform()
{
	const SFLOAT PI = 3.14159265359;

	//We first retrieve the position of the buttons
	egtGetInstanceTranslation(eyeGTCanvas, PointA, &x1, &y1);
	egtGetInstanceTranslation(eyeGTCanvas, PointB, &x2, &y2);
	egtGetInstanceTranslation(eyeGTCanvas, PointC, &x3, &y3);

	if (x1 < 0.0)			x1 = 0.0;
	if (x1 > ClientWidth)	x1 = ClientWidth;
	if (y1 < 0.0)			y1 = 0.0;
	if (y1 > ClientHeight) y1 = ClientHeight;
	if (x2 < 0.0)			x2 = 0.0;
	if (x2 > ClientWidth)	x2 = ClientWidth;
	if (y2 < 0.0)			y2 = 0.0;
	if (y2 > ClientHeight) y2 = ClientHeight;
	if (x3 < 0.0)			x3 = 0.0;
	if (x3 > ClientWidth)	x3 = ClientWidth;
	if (y3 < 0.0)			y3 = 0.0;
	if (y3 > ClientHeight) y3 = ClientHeight;
	
	//Calculate the delta between the buttons
	SFLOAT abx = x1-x2;
	SFLOAT aby = y1-y2;
	SFLOAT cax = x3-x1;
	SFLOAT cay = y3-y1;
	SFLOAT bcx = x2-x3;
	SFLOAT bcy = y2-y3;
	
	//Buttons are clockwise or counterclockwise?
	SFLOAT dir = (cax*bcy-cay*bcx<0.0) ? 1 : -1;
	
	//Calculate the sides length
	SFLOAT ab = abx*abx+aby*aby;
	SFLOAT ca = cax*cax+cay*cay;
	SFLOAT bc = bcx*bcx+bcy*bcy;
	SFLOAT prod = ab*bc*ca;
	SFLOAT sum = ab+bc+ca;
	
	//Find the longest side
	SFLOAT mx = (ab>ca) ? ((ab>bc) ? ab : (bc)) : ((ca>bc) ? ca : (bc));
	
	//and its relative height
	SFLOAT hh = prod/mx/mx-sum*sum/4/mx-mx+sum;

	SFLOAT pp;

	if (mx == ab) 
	{
		pp = 1.73205081/sqrt(1+2*sqrt((bc-hh)/(ca-hh)));
		
		egtRotateInstance(eyeGTCanvas, tri1, atan2(-aby, -abx)*180.0/PI, false);
		egtRotateInstance(eyeGTCanvas, type, 0.0, false);
		egtTranslateInstance(eyeGTCanvas, tri1, x2, y2, false);
	} 
	else if (mx == bc) 
	{
		pp = 1.73205081/sqrt(1+2*sqrt((ca-hh)/(ab-hh)));
		
		egtRotateInstance(eyeGTCanvas, tri1, atan2(-bcy, -bcx)*180.0/PI, false);
		egtRotateInstance(eyeGTCanvas, type, 240.0, false);
		egtTranslateInstance(eyeGTCanvas, tri1, x2, y2, false);
	} else {
		pp = 1.73205081/sqrt(1+2*sqrt((ab-hh)/(bc-hh)));

		egtRotateInstance(eyeGTCanvas, tri1, atan2(-cay, -cax)*180.0/PI, false);
		egtRotateInstance(eyeGTCanvas, type, 120.0, false);
		egtTranslateInstance(eyeGTCanvas, tri1, x2, y2, false);
	}

	SFLOAT rr = sqrt(pp*pp+3)/2;

	egtScaleInstance(eyeGTCanvas, base, pp * 100.0 / 100.0, 100.0 / 100.0, false);
	egtRotateInstance(eyeGTCanvas, base, atan(1.73205081/pp)*180.0/PI, false);

	egtScaleInstance(eyeGTCanvas, tri1, (sqrt(mx)/rr) / 100.0, (1.15470054*sqrt(hh)*rr/pp*dir) / 100.0, false);
}
